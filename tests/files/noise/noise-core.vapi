/* noise-core.vapi generated by valac 0.26.2, do not modify. */

namespace Build {
	[CCode (cheader_filename = "noise-core.h")]
	public const string CMAKE_INSTALL_PREFIX;
	[CCode (cheader_filename = "noise-core.h")]
	public const string DATADIR;
	[CCode (cheader_filename = "noise-core.h")]
	public const string GETTEXT_PACKAGE;
	[CCode (cheader_filename = "noise-core.h")]
	public const string ICON_DIR;
	[CCode (cheader_filename = "noise-core.h")]
	public const string PKG_DATADIR;
	[CCode (cheader_filename = "noise-core.h")]
	public const string PLUGIN_DIR;
	[CCode (cheader_filename = "noise-core.h")]
	public const string RELEASE_NAME;
	[CCode (cheader_filename = "noise-core.h")]
	public const string VERSION;
	[CCode (cheader_filename = "noise-core.h")]
	public const string VERSION_INFO;
}
namespace Noise {
	namespace Compare {
		[CCode (cheader_filename = "noise-core.h")]
		public static int album_artists (Noise.Media a, Noise.Media b);
		[CCode (cheader_filename = "noise-core.h")]
		public static int albums (Noise.Media a, Noise.Media b);
		[CCode (cheader_filename = "noise-core.h")]
		public static int artists (Noise.Media a, Noise.Media b);
		[CCode (cheader_filename = "noise-core.h")]
		public static int genres (Noise.Media a, Noise.Media b);
		[CCode (cheader_filename = "noise-core.h")]
		public static int titles (Noise.Media a, Noise.Media b);
		[CCode (cheader_filename = "noise-core.h")]
		public static int track_numbers (Noise.Media a, Noise.Media b);
	}
	namespace FileUtils {
		[CCode (cheader_filename = "noise-core.h")]
		public const string APP_NAME;
		[CCode (cheader_filename = "noise-core.h")]
		public static int count_music_files (GLib.File music_folder, Gee.Collection<string> files);
		[CCode (cheader_filename = "noise-core.h")]
		public static int count_playlists_files (GLib.File playlist_folder, ref Gee.LinkedList<string> files);
		[CCode (cheader_filename = "noise-core.h")]
		public static async uint enumerate_files_async (GLib.File folder, string[]? types = null, bool recursive = true, out Gee.Collection<GLib.File>? files = null, GLib.Cancellable? cancellable = null);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool equal_func (GLib.File a, GLib.File b);
		[CCode (cheader_filename = "noise-core.h")]
		public static GLib.File get_cache_directory ();
		[CCode (cheader_filename = "noise-core.h")]
		public static GLib.File get_data_directory ();
		[CCode (cheader_filename = "noise-core.h")]
		public static string get_extension (string filename);
		[CCode (cheader_filename = "noise-core.h")]
		public static GLib.File? get_new_destination (Noise.Media s);
		[CCode (cheader_filename = "noise-core.h")]
		public static async uint64 get_size_async (GLib.File file_or_dir, GLib.Cancellable? cancellable = null);
		[CCode (cheader_filename = "noise-core.h")]
		public static async bool is_directory_async (GLib.File dir, GLib.Cancellable? cancellable = null);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool is_valid_content_type (string file_content_type, string[]? content_types = null);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool is_valid_playlist_type (string file_content_type, string[]? content_types = null);
		[CCode (cheader_filename = "noise-core.h")]
		public static async bool query_exists_async (GLib.File file_or_dir, GLib.Cancellable? cancellable = null);
		[CCode (cheader_filename = "noise-core.h")]
		public static async string? query_name_async (GLib.File file_or_dir, GLib.Cancellable? cancellable = null);
	}
	namespace Numeric {
		[CCode (cheader_filename = "noise-core.h")]
		public const uint64 MILI_INV;
		[CCode (cheader_filename = "noise-core.h")]
		public const uint64 NANO_INV;
		[CCode (cheader_filename = "noise-core.h")]
		public static int compare (int64 a, int64 b);
		[CCode (cheader_filename = "noise-core.h")]
		[Deprecated (replacement = "GLib.Math.roundf")]
		public static int int_from_float (float number);
		[CCode (cheader_filename = "noise-core.h")]
		[Deprecated (replacement = "GLib.Math.truncf")]
		public static int lowest_int_from_float (float number);
		[CCode (cheader_filename = "noise-core.h")]
		[Deprecated (replacement = "GLib.Math.trunc")]
		public static uint lowest_uint_from_double (double number);
		[CCode (cheader_filename = "noise-core.h")]
		[Deprecated (replacement = "GLib.Math.round")]
		public static uint uint_from_double (double number);
		[CCode (cheader_filename = "noise-core.h")]
		public static uint64 uint_from_string (string str);
	}
	namespace PixbufUtils {
		[CCode (cheader_filename = "noise-core.h")]
		public static async Gdk.Pixbuf? get_pixbuf_from_file_async (GLib.File file, GLib.Cancellable? c = null) throws GLib.Error;
		[CCode (cheader_filename = "noise-core.h")]
		public static async Gdk.Pixbuf? get_pixbuf_from_file_at_scale_async (GLib.File file, int width, int height, bool preserve_aspect_ratio, GLib.Cancellable? c = null) throws GLib.Error;
		[CCode (cheader_filename = "noise-core.h")]
		public static Gdk.Pixbuf? render_pixbuf_shadow (Gdk.Pixbuf pixbuf, int shadow_size = 5, double alpha = 0.75);
		[CCode (cheader_filename = "noise-core.h")]
		public static async void save_pixbuf_async (Gdk.Pixbuf pixbuf, GLib.File dest_file, string image_format, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	namespace PlaylistsUtils {
		[CCode (cheader_filename = "noise-core.h")]
		public static void export_playlist (Noise.Playlist p);
		[CCode (cheader_filename = "noise-core.h")]
		public static string get_new_playlist_name (Gee.Collection<Noise.Playlist> playlists, string? name = null);
		[CCode (cheader_filename = "noise-core.h")]
		public static string get_playlist_m3u_file (Noise.Playlist p, string without_path);
		[CCode (cheader_filename = "noise-core.h")]
		public static Gee.HashMap<string,Gee.LinkedList<string>> get_playlists_to_import (string? set_title = "Playlist") throws GLib.Error;
		[CCode (cheader_filename = "noise-core.h")]
		public static void import_from_playlist_file_info (Gee.HashMap<string,Gee.LinkedList<string>> playlists, Noise.Library library);
		[CCode (cheader_filename = "noise-core.h")]
		public static void parse_index_and_value (string prefix, string line, ref Gee.HashMap<int,string> map);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool parse_paths_from_m3u (string uri, ref Gee.LinkedList<string> locals);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool parse_paths_from_pls (string uri, ref Gee.LinkedList<string> locals, ref string title);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool save_playlist_m3u (Noise.Playlist p, string folder_uri, string without_path);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool save_playlist_pls (Noise.Playlist p, string folder_uri);
		[CCode (cheader_filename = "noise-core.h")]
		public static Noise.StaticPlaylist static_playlist_from_smartplaylist (Noise.SmartPlaylist sp);
	}
	namespace Plugins {
		[CCode (cheader_filename = "noise-core.h")]
		public class Interface : GLib.Object {
			public enum Hook {
				CONTEXT,
				SIDEBAR,
				MAIN_MENU,
				ADDONS_MENU,
				BOTTOMBAR,
				TOOLBAR,
				SOURCE_VIEW,
				SETTINGS_WINDOW,
				WINDOW
			}
			public delegate void HookFunction ();
			public delegate void HookFunctionArg (GLib.Object object);
			public Interface (Noise.Plugins.Manager manager);
			public void register_function (Noise.Plugins.Interface.Hook hook, Noise.Plugins.Interface.HookFunction hook_function);
			public void register_function_arg (Noise.Plugins.Interface.Hook hook, Noise.Plugins.Interface.HookFunctionArg hook_function);
			public void register_function_signal (Noise.Plugins.Interface.Hook hook, string signal_name, GLib.Object obj);
			public Gtk.Menu addons_menu { get; private set; }
			public GLib.List<Gtk.TextView> all_source_view { get; private set; }
			public string? argument { get; internal set; }
			public Gtk.Notebook bottombar { get; internal set; }
			public Gtk.Notebook context { get; internal set; }
			public Gtk.Menu main_menu { get; private set; }
			public Gtk.Application noise_app { get; internal set; }
			public string set_name { get; internal set; }
			public Gtk.Notebook sidebar { get; internal set; }
			public Gtk.Toolbar toolbar { get; internal set; }
			public Gtk.Window window { get; private set; }
		}
		[CCode (cheader_filename = "noise-core.h")]
		public class Manager : GLib.Object {
			public static Noise.Plugins.Manager get_default ();
			public Gtk.Widget get_view ();
			public void hook_app (Gtk.Application app);
			public void hook_example (string arg);
			public Gtk.Notebook context { set; }
			public Gtk.Application noise_app { set; }
			public Noise.Plugins.Interface plugin_iface { get; private set; }
			public Gtk.Notebook sidebar { set; }
			public Gtk.Toolbar toolbar { set; }
			public signal void hook_addons_menu (Gtk.Menu menu);
			public signal void hook_main_menu (Gtk.Menu menu);
			public signal void hook_new_window (Gtk.Window window);
			public signal void hook_notebook_bottom (Gtk.Notebook notebook);
			public signal void hook_notebook_context ();
			public signal void hook_notebook_sidebar ();
			public signal void hook_preferences_window (Gtk.Window window);
			public signal void hook_set_arg (string set_name, string? set_arg);
			public signal void hook_source_view (Gtk.TextView view);
			public signal void hook_toolbar ();
			public signal void hook_toolbar_context_menu (Gtk.Menu menu);
		}
	}
	namespace Search {
		[CCode (cheader_filename = "noise-core.h")]
		public static int get_rating_from_string (string rating_string);
		[CCode (cheader_filename = "noise-core.h")]
		public static string get_valid_search_string (string s);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool match_fields_to_media (Noise.Media media, string album_artist = "", string album = "", string genre = "", string grouping = "", string composer = "", int year = -1, int rating = -1);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool match_string_to_media (Noise.Media m, string search);
		[CCode (cheader_filename = "noise-core.h")]
		public static void search_in_media_list (Gee.Collection<Noise.Media> to_search, out Gee.Collection<Noise.Media> results, string album_artist = "", string album = "", string genre = "", string grouping = "", string composer = "", int year = -1, int rating = -1, GLib.Cancellable? cancellable = null);
	}
	namespace Settings {
		[CCode (cheader_filename = "noise-core.h")]
		public class Equalizer : Granite.Services.Settings {
			public Gee.Collection<Noise.EqualizerPreset> getPresets ();
			public static Noise.Settings.Equalizer get_default ();
			public bool auto_switch_preset { get; set; }
			public string[] custom_presets { get; set; }
			public bool equalizer_enabled { get; set; }
			public string selected_preset { get; set; }
		}
		[CCode (cheader_filename = "noise-core.h")]
		public class Main : Granite.Services.Settings {
			public static Noise.Settings.Main get_default ();
			public bool close_while_playing { get; set; }
			public bool copy_imported_music { get; set; }
			public int last_media_playing { get; set; }
			public int last_media_position { get; set; }
			public int last_playlist_playing { get; set; }
			public string[] minimize_while_playing_shells { get; set; }
			public string music_folder { get; set; }
			public string music_mount_name { get; set; }
			public string path_string { get; set; }
			public string[] plugins_disabled { get; set; }
			public Noise.Settings.Repeat repeat_mode { get; set; }
			public string search_string { get; set; }
			public bool show_notifications { get; set; }
			public Noise.Settings.Shuffle shuffle_mode { get; set; }
			public bool update_folder_hierarchy { get; set; }
			public bool write_metadata_to_file { get; set; }
		}
		[CCode (cheader_filename = "noise-core.h")]
		public class SavedState : Granite.Services.Settings {
			public static Noise.Settings.SavedState get_default ();
			public bool column_browser_enabled { get; set; }
			public int column_browser_height { get; set; }
			public int column_browser_position { get; set; }
			public string[] column_browser_visible_columns { get; set; }
			public int column_browser_width { get; set; }
			public bool more_visible { get; set; }
			public int more_width { get; set; }
			public bool show_album_art_in_list_view { get; set; }
			public int sidebar_width { get; set; }
			public int view_mode { get; set; }
			public int window_height { get; set; }
			public Noise.Settings.WindowState window_state { get; set; }
			public int window_width { get; set; }
		}
		[CCode (cheader_filename = "noise-core.h")]
		public enum Repeat {
			OFF,
			MEDIA,
			ALBUM,
			ARTIST,
			ALL
		}
		[CCode (cheader_filename = "noise-core.h")]
		public enum Shuffle {
			OFF,
			ALL
		}
		[CCode (cheader_filename = "noise-core.h")]
		public enum WindowState {
			NORMAL,
			MAXIMIZED,
			FULLSCREEN
		}
	}
	namespace SettingsWindow {
		[CCode (cheader_filename = "noise-core.h")]
		public class NoteBook_Page : Gtk.Grid {
			public NoteBook_Page (string name);
			public void add_full_option (Gtk.Widget big_widget, ref int row);
			public void add_option (Gtk.Widget label, Gtk.Widget switcher, ref int row);
			public void add_section (Gtk.Label name, ref int row);
			public string name { get; private set; }
		}
	}
	namespace String {
		[CCode (cheader_filename = "noise-core.h")]
		public static void base_search_method (string search, out int parsed_rating, out string parsed_search_string);
		[CCode (cheader_filename = "noise-core.h")]
		public static string canonicalize_for_search (string str);
		[CCode (cheader_filename = "noise-core.h")]
		public static int compare (string? a, string? b);
		[CCode (cheader_filename = "noise-core.h")]
		public static string escape (string text);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool is_empty (string? text, bool check_white_space);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool is_white_space (string text);
		[CCode (cheader_filename = "noise-core.h")]
		public static string? locale_to_utf8 (string string_locale);
		[CCode (cheader_filename = "noise-core.h")]
		public static string to_title_case (string text);
	}
	namespace TimeUtils {
		[CCode (cheader_filename = "noise-core.h")]
		public const uint SECONDS_PER_DAY;
		[CCode (cheader_filename = "noise-core.h")]
		public const uint SECONDS_PER_HOUR;
		[CCode (cheader_filename = "noise-core.h")]
		public const uint SECONDS_PER_MINUTE;
		[CCode (cheader_filename = "noise-core.h")]
		public static uint64 miliseconds_to_nanoseconds (uint miliseconds);
		[CCode (cheader_filename = "noise-core.h")]
		public static uint nanoseconds_to_miliseconds (uint64 nanoseconds);
		[CCode (cheader_filename = "noise-core.h")]
		public static string pretty_length (uint seconds);
		[CCode (cheader_filename = "noise-core.h")]
		public static string pretty_length_from_ms (uint64 mseconds);
		[CCode (cheader_filename = "noise-core.h")]
		public static string pretty_length_from_ns (uint64 nseconds);
		[CCode (cheader_filename = "noise-core.h")]
		public static string pretty_timestamp_from_time (GLib.Time dt);
		[CCode (cheader_filename = "noise-core.h")]
		public static string pretty_timestamp_from_uint (uint time);
		[CCode (cheader_filename = "noise-core.h")]
		public static string time_string_from_miliseconds (uint64 miliseconds);
		[CCode (cheader_filename = "noise-core.h")]
		public static string time_string_from_nanoseconds (uint64 nanoseconds);
		[CCode (cheader_filename = "noise-core.h")]
		public static string time_string_from_seconds (uint seconds);
	}
	namespace UI {
		[CCode (cheader_filename = "noise-core.h")]
		public static void make_window_draggable (Gtk.Window window);
		[CCode (cheader_filename = "noise-core.h")]
		public static void set_tree_view_column_fixed_width (Gtk.Widget treeview, Gtk.TreeViewColumn column, Gtk.CellRendererText renderer, string[] strings, int padding);
		[CCode (cheader_filename = "noise-core.h")]
		public static Gtk.Widget wrap_alignment (Gtk.Widget widget, int top, int right, int bottom, int left);
	}
	namespace Utils {
		[CCode (cheader_filename = "noise-core.h")]
		public static Gee.Collection<T> copy_collection<T> (Gee.Collection<T> orig);
		[CCode (cheader_filename = "noise-core.h")]
		public static bool flags_set (int flags, int to_check);
		[CCode (cheader_filename = "noise-core.h")]
		public static string? get_desktop_shell ();
		[CCode (cheader_filename = "noise-core.h")]
		public static bool is_cancelled (GLib.Cancellable? cancellable);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class Album : GLib.Object {
		public Album ();
		public void add_media (Noise.Media m);
		public bool contains (Noise.Media m);
		public Album.from_media (Noise.Media m);
		public string get_display_artist ();
		public string get_display_name ();
		public string get_hashkey ();
		public Gee.Collection<Noise.Media> get_media (uint n_disc = 1);
		public bool is_compatible (Noise.Media m);
		public void remove_media (Noise.Media m);
		public string to_string ();
		public string artist { get; set; }
		public bool is_empty { get; }
		public uint n_discs { get; set; }
		public uint n_media { get; }
		public string name { get; set; }
		public uint year { get; set; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class CompareFuncHolder {
		public weak Gtk.TreeIterCompareFunc sort_func;
		public CompareFuncHolder (Gtk.TreeIterCompareFunc func);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class DeviceManager : GLib.Object {
		public void add_device_preferences (Noise.DevicePreferences dp);
		public void device_initialized (Noise.Device d);
		public Gee.ArrayList<weak GLib.Mount> get_available_mounts ();
		public static Noise.DeviceManager get_default ();
		public Noise.DevicePreferences? get_device_preferences (string id);
		public Gee.ArrayList<weak Noise.Device> get_initialized_devices ();
		public void get_pre_existing_mounts ();
		public virtual void mount_changed (GLib.Mount mount);
		public virtual void mount_pre_unmount (GLib.Mount mount);
		public void set_device_preferences (Gee.Collection<Noise.DevicePreferences> device_preferences);
		public signal void device_added (Noise.Device d);
		public signal void device_name_changed (Noise.Device d);
		public signal void device_removed (Noise.Device d);
		public signal void mount_added (GLib.Mount mount);
		public signal void mount_removed (GLib.Mount mount);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class DevicePreferences : GLib.Object {
		public DevicePreferences (string id);
		public Noise.Playlist audiobook_playlist { get; set; }
		public string id { get; set construct; }
		public int last_sync_time { get; set; }
		public Noise.Playlist music_playlist { get; set; }
		public Noise.Playlist podcast_playlist { get; set; }
		public bool sync_all_audiobooks { get; set; }
		public bool sync_all_music { get; set; }
		public bool sync_all_podcasts { get; set; }
		public bool sync_audiobooks { get; set; }
		public bool sync_music { get; set; }
		public bool sync_podcasts { get; set; }
		public bool sync_when_mounted { get; set; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class Equalizer : GLib.Object {
		public Gst.Element element;
		public Equalizer ();
		public static Gee.Collection<Noise.EqualizerPreset> get_default_presets ();
		public void setGain (int index, double gain);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class EqualizerPreset : GLib.Object {
		public Gee.ArrayList<int> gains;
		public string name;
		public EqualizerPreset ();
		public EqualizerPreset.basic (string name);
		public EqualizerPreset.from_string (string data);
		public int getGain (int index);
		public void setGain (int index, int val);
		public string to_string ();
		public EqualizerPreset.with_gains (string name, int[] items);
		public bool is_default { get; set; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class Icon : GLib.Object {
		public Icon (string file_name);
		public GLib.File? get_file (int size = 16);
		public Gtk.IconInfo? get_icon_info (int size);
		public Gdk.Pixbuf? render (Gtk.IconSize size, Gtk.StyleContext? style_context = null);
		public Gdk.Pixbuf? render_at_size (int pixel_size, Gtk.StyleContext? style_context = null);
		public Gtk.Image render_image (Gtk.IconSize size);
		public Gtk.Image render_image_at_size (int pixel_size);
		public string? file_name { get; private set; }
		public GLib.Icon gicon { get; private set; }
		public string? name { get; private set; }
		public static Gtk.IconTheme theme { get; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class Icons {
		public const int DEFAULT_ALBUM_ART_SIZE;
		public Icons ();
		public static void init ();
		public static Gdk.Pixbuf? render_icon (string icon_name, Gtk.IconSize size, Gtk.StyleContext? context = null);
		public static Gtk.Image? render_image (string icon_name, Gtk.IconSize size);
		public static Noise.Icon AUDIO_CD { get; private set; }
		public static Noise.Icon AUDIO_DEVICE { get; private set; }
		public static Noise.Icon BAN { get; private set; }
		public static Noise.Icon DEFAULT_ALBUM_ART { get; private set; }
		public static Noise.Icon DEFAULT_ALBUM_ART_2 { get; private set; }
		public static Noise.Icon EJECT_SYMBOLIC { get; private set; }
		public static Noise.Icon EQ_SYMBOLIC { get; private set; }
		public static Noise.Icon GENERIC_AUDIO { get; private set; }
		public static Noise.Icon HISTORY { get; private set; }
		public static Noise.Icon IMPORT { get; private set; }
		public static Noise.Icon LIST_ADD_SYMBOLIC { get; private set; }
		public static Noise.Icon LOVE { get; private set; }
		public static Noise.Icon MUSIC { get; private set; }
		public static Noise.Icon MUSIC_FOLDER { get; private set; }
		public static Noise.Icon NETWORK_DEVICE { get; private set; }
		public static Noise.Icon NOISE { get; private set; }
		public static Noise.Icon NOT_STARRED { get; private set; }
		public static Noise.Icon NOT_STARRED_SYMBOLIC { get; private set; }
		public static Noise.Icon NOW_PLAYING_SYMBOLIC { get; private set; }
		public static Noise.Icon PANE_HIDE_SYMBOLIC { get; private set; }
		public static Noise.Icon PANE_SHOW_SYMBOLIC { get; private set; }
		public static Noise.Icon PLAYLIST { get; private set; }
		public static Noise.Icon PROCESS_COMPLETED { get; private set; }
		public static Noise.Icon PROCESS_ERROR { get; private set; }
		public static Noise.Icon PROCESS_STOP { get; private set; }
		public static Noise.Icon QUEUE { get; private set; }
		public static Noise.Icon REFRESH_SYMBOLIC { get; private set; }
		public static Noise.Icon REPEAT_OFF { get; private set; }
		public static Noise.Icon REPEAT_ON { get; private set; }
		public static Noise.Icon REPEAT_ONE { get; private set; }
		public static Noise.Icon SHUFFLE_OFF { get; private set; }
		public static Noise.Icon SHUFFLE_ON { get; private set; }
		public static Noise.Icon SMART_PLAYLIST { get; private set; }
		public static Noise.Icon STARRED { get; private set; }
		public static Noise.Icon STARRED_SYMBOLIC { get; private set; }
		public static Noise.Icon VIEW_COLUMN { get; private set; }
		public static Noise.Icon VIEW_DETAILS { get; private set; }
		public static Noise.Icon VIEW_ICONS { get; private set; }
		public static Noise.Icon VIEW_VIDEO { get; private set; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class LibrariesManager : GLib.Object {
		public string current_operation;
		public Noise.Library local_library;
		public double progress;
		public LibrariesManager ();
		public void add_library (Noise.Library library);
		public bool do_progress_notification_with_timeout ();
		public Noise.Library? get_library_from_index (int index);
		public void remove_library (Noise.Library library);
		public void search_for_string (string search);
		public async void transfer_medias_async (Gee.Collection<Noise.Media> list);
		public void transfer_to_local_library (Gee.Collection<Noise.Media> to_transfer);
		public signal void cancel_transfer ();
		public signal void library_added (Noise.Library library);
		public signal void library_removed (Noise.Library library);
		public signal void operation_terminated ();
	}
	[CCode (cheader_filename = "noise-core.h")]
	public abstract class Library : GLib.Object {
		public Library ();
		public abstract void add_files_to_library (Gee.Collection<string> files);
		public abstract void add_media (Noise.Media s);
		public abstract void add_medias (Gee.Collection<Noise.Media> new_media);
		public abstract void add_playlist (Noise.StaticPlaylist p);
		public abstract void add_smart_playlist (Noise.SmartPlaylist p);
		public abstract bool doing_file_operations ();
		public abstract Noise.Media? find_media (Noise.Media to_find);
		public abstract void finish_file_operations ();
		public abstract Gee.Collection<Noise.Media> get_medias ();
		public abstract Gee.Collection<Noise.StaticPlaylist> get_playlists ();
		public abstract Gee.Collection<Noise.Media> get_search_result ();
		public abstract Gee.Collection<Noise.SmartPlaylist> get_smart_playlists ();
		public abstract void initialize_library ();
		public abstract Noise.Media? media_from_file (GLib.File file);
		public abstract Noise.Media? media_from_id (int id);
		public void media_from_name (Gee.Collection<Noise.Media> tests, ref Gee.LinkedList<int> found, ref Gee.LinkedList<Noise.Media> not_found);
		public abstract Noise.Media? media_from_uri (string uri);
		public abstract Gee.Collection<Noise.Media> medias_from_ids (Gee.Collection<int> ids);
		public abstract Gee.Collection<Noise.Media> medias_from_uris (Gee.Collection<string> uris);
		public int playlist_count_without_read_only ();
		public abstract Noise.StaticPlaylist? playlist_from_id (int id);
		public abstract Noise.StaticPlaylist? playlist_from_name (string name);
		public abstract void remove_media (Noise.Media s, bool trash);
		public abstract void remove_medias (Gee.Collection<Noise.Media> toRemove, bool trash);
		public abstract void remove_playlist (int id);
		public abstract void remove_smart_playlist (int id);
		public abstract void search_medias (string search);
		public abstract Noise.SmartPlaylist? smart_playlist_from_id (int id);
		public abstract Noise.SmartPlaylist? smart_playlist_from_name (string name);
		public abstract bool start_file_operations (string? message);
		public abstract bool support_playlists ();
		public abstract bool support_smart_playlists ();
		public abstract void update_media (Noise.Media s, bool updateMeta, bool record_time);
		public abstract void update_medias (Gee.Collection<Noise.Media> updates, bool updateMeta, bool record_time);
		public signal void file_operations_done ();
		public signal void file_operations_started ();
		public signal void media_added (Gee.Collection<Noise.Media> medias);
		public signal void media_imported (Gee.Collection<Noise.Media> medias);
		public signal void media_removed (Gee.Collection<Noise.Media> medias);
		public signal void media_updated (Gee.Collection<Noise.Media> medias);
		public signal void playlist_added (Noise.StaticPlaylist playlist);
		public signal void playlist_name_updated (Noise.StaticPlaylist playlist);
		public signal void playlist_removed (Noise.StaticPlaylist playlist);
		public signal void search_finished ();
		public signal void smartplaylist_added (Noise.SmartPlaylist smartplaylist);
		public signal void smartplaylist_name_updated (Noise.SmartPlaylist smartplaylist);
		public signal void smartplaylist_removed (Noise.SmartPlaylist smartplaylist);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class Media : GLib.Object {
		public Media (string uri);
		public Noise.Media copy ();
		public Media.from_file (GLib.File file);
		public string get_album_hashkey ();
		public string get_display_album ();
		public string get_display_album_artist (bool use_artist_fallback = true);
		public string get_display_artist ();
		public string get_display_composer ();
		public string get_display_filename ();
		public string get_display_genre ();
		public string get_display_location ();
		public string get_display_title ();
		public string get_title_markup ();
		public static bool is_valid_string_field (string? text);
		public string album { get; set; }
		public string album_artist { get; set; }
		public uint album_count { get; set; }
		public Noise.Album album_info { get; set; }
		public uint album_number { get; set; }
		public string artist { get; set; }
		public uint bitrate { get; set; }
		public uint bpm { get; set; }
		public string comment { get; set; }
		public string composer { get; set; }
		public uint date_added { get; set; }
		public GLib.File file { get; set; }
		public bool file_exists { get; }
		public uint64 file_size { get; set; }
		public string genre { get; set; }
		public string grouping { get; set; }
		public bool has_embedded { get; set; }
		public bool isPreview { get; set; }
		public bool isTemporary { get; set; }
		public uint last_modified { get; set; }
		public uint last_played { get; set; }
		public uint length { get; set; }
		public bool location_unknown { get; set; }
		public string lyrics { get; set; }
		public uint play_count { get; set; }
		public uint rating { get; set; }
		public int resume_pos { get; set; }
		public int rowid { get; set; }
		public uint samplerate { get; set; }
		public bool showIndicator { get; set; }
		public uint skip_count { get; set; }
		public string title { get; set; }
		public uint track { get; set; }
		public uint track_count { get; set; }
		public GLib.Icon unique_status_image { get; set; }
		public string uri { owned get; set; }
		public uint year { get; set; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class NotificationManager : GLib.Object {
		public NotificationManager ();
		public virtual void doAlertNotification (string title, string message);
		public virtual void doProgressNotification (string? message, double progress);
		public virtual void doSongNotification (string? message);
		public static Noise.NotificationManager get_default ();
		public virtual void showProgressNotification ();
		public virtual void showSongNotification ();
		public signal void alertNotification (string title, string message);
		public signal void progressNotification (string? message, double progress);
		public signal void progress_canceled ();
		public signal void searchCover (Noise.Media m);
		public signal void songNotification (string message);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class Pipeline : GLib.Object {
		public Gst.Element audiobin;
		public Gst.Element audiosink;
		public Gst.Element audiosinkqueue;
		public Gst.Element audiotee;
		public Gst.Bus bus;
		public Noise.Equalizer eq;
		public Gst.Element eq_audioconvert;
		public Gst.Element eq_audioconvert2;
		public Gst.Pad pad;
		public Gst.Pipeline pipe;
		public Gst.Element playbin;
		public Gst.Element preamp;
		public Pipeline ();
		public void disableEqualizer ();
		public void enableEqualizer ();
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class PixbufCache {
		public delegate Gdk.Pixbuf? FilterFunction (string key, Gdk.Pixbuf orig_pixbuf);
		public weak Noise.PixbufCache.FilterFunction? filter_func;
		public const string[] IMAGE_TYPES;
		public PixbufCache (GLib.File image_dir, Gdk.PixbufFormat? image_format = null);
		public async void cache_image_async (string key, Gdk.Pixbuf image);
		public async void cache_image_from_file_async (string key, GLib.File image_file, GLib.Cancellable? c = null);
		public Gdk.Pixbuf? decache_image (string key);
		public GLib.File get_cached_image_file (string key);
		public Gdk.Pixbuf? get_image (string key);
		public async Gdk.Pixbuf? get_image_async (string key, bool lookup_file = true);
		public bool has_image (string key);
		public Gdk.PixbufFormat image_format { get; private set; }
		public Gee.Map<string,Gdk.Pixbuf> images { owned get; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public abstract class Playlist : GLib.Object {
		public GLib.Icon icon;
		public Playlist ();
		public abstract void add_media (Noise.Media to_remove);
		public abstract void add_medias (Gee.Collection<Noise.Media> to_add);
		public abstract void clear ();
		public bool is_empty ();
		public abstract void remove_media (Noise.Media to_remove);
		public abstract void remove_medias (Gee.Collection<Noise.Media> to_remove);
		public Gee.LinkedList<Noise.Media> medias { get; set; }
		public string name { get; set; }
		public int rowid { get; set; }
		public signal void cleared ();
		public signal void media_added (Gee.Collection<Noise.Media> media);
		public signal void media_removed (Gee.Collection<Noise.Media> media);
		public signal void request_play ();
		public signal void updated (string? old_name = null);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class SmartPlaylist : Noise.Playlist {
		public enum ConditionalType {
			ALL,
			ANY
		}
		public Gee.ArrayList<Noise.SmartQuery> _queries;
		public const string QUERY_SEPARATOR;
		public const string VALUE_SEPARATOR;
		public SmartPlaylist (Gee.Collection<Noise.Media> library);
		public override void add_media (Noise.Media m);
		public override void add_medias (Gee.Collection<Noise.Media> to_add);
		public void add_queries (Gee.Collection<Noise.SmartQuery> queries);
		public void add_query (Noise.SmartQuery s);
		public override void clear ();
		public void clearQueries ();
		public bool media_matches_query (Noise.SmartQuery q, Noise.Media s);
		public Gee.ArrayList<Noise.SmartQuery> queries ();
		public void queries_from_string (string q);
		public string queries_to_string ();
		public void reanalyze ();
		public override void remove_media (Noise.Media to_remove);
		public override void remove_medias (Gee.Collection<Noise.Media> to_remove);
		public void update_medias (Gee.Collection<Noise.Media> medias);
		public Noise.SmartPlaylist.ConditionalType conditional { get; set; }
		public bool limit { get; set; }
		public int limit_amount { get; set; }
		public int query_count { get; set; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class SmartQuery : GLib.Object {
		public enum ComparatorType {
			IS,
			IS_NOT,
			CONTAINS,
			NOT_CONTAINS,
			IS_EXACTLY,
			IS_AT_MOST,
			IS_AT_LEAST,
			IS_WITHIN,
			IS_BEFORE
		}
		public enum FieldType {
			ALBUM,
			ARTIST,
			BITRATE,
			COMMENT,
			COMPOSER,
			DATE_ADDED,
			DATE_RELEASED,
			GENRE,
			GROUPING,
			LAST_PLAYED,
			LENGTH,
			PLAYCOUNT,
			RATING,
			SKIPCOUNT,
			TITLE,
			YEAR
		}
		public SmartQuery ();
		public SmartQuery.with_info (Noise.SmartQuery.FieldType field, Noise.SmartQuery.ComparatorType comparator, string value);
		public Noise.SmartQuery.ComparatorType comparator { get; set; }
		public Noise.SmartQuery.FieldType field { get; set; }
		public int rowid { get; set; }
		public string value { get; set; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class StaticPlaylist : Noise.Playlist {
		public StaticPlaylist ();
		public override void add_media (Noise.Media m);
		public override void add_medias (Gee.Collection<Noise.Media> to_add);
		public override void clear ();
		public override void remove_media (Noise.Media to_remove);
		public override void remove_medias (Gee.Collection<Noise.Media> to_remove);
		public StaticPlaylist.with_info (int rowid, string name);
		public bool allow_duplicate { get; set; }
		public bool read_only { get; set; }
		public bool show_badge { get; set; }
	}
	[CCode (cheader_filename = "noise-core.h")]
	public class Threads {
		public delegate void TaskFunc ();
		public static bool add (Noise.Threads.TaskFunc task);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public interface Device : GLib.Object {
		public Gee.Collection<Noise.Media> delete_doubles (Gee.Collection<Noise.Media> source_list, Gee.Collection<Noise.Media> to_remove);
		public abstract void eject ();
		public abstract void finish_initialization ();
		public abstract string getContentType ();
		public abstract string getDisplayName ();
		public abstract string getEmptyDeviceDescription ();
		public abstract string getEmptyDeviceTitle ();
		public abstract uint64 get_capacity ();
		public abstract Gtk.Widget? get_custom_view ();
		public abstract string get_fancy_capacity ();
		public abstract string get_fancy_description ();
		public abstract uint64 get_free_space ();
		public abstract GLib.Icon get_icon ();
		public abstract Noise.Library get_library ();
		public abstract GLib.Mount? get_mount ();
		public abstract Noise.DevicePreferences get_preferences ();
		public string get_unique_identifier ();
		public abstract string get_uri ();
		public abstract uint64 get_used_space ();
		public abstract bool only_use_custom_view ();
		public abstract bool read_only ();
		public abstract void setDisplayName (string name);
		public abstract void set_icon (GLib.Icon icon);
		public abstract void set_mount (GLib.Mount mount);
		public abstract bool start_initialization ();
		public abstract void synchronize ();
		public abstract void unmount ();
		public bool will_fit (Gee.Collection<Noise.Media> list);
		public bool will_fit_without (Gee.Collection<Noise.Media> list, Gee.Collection<Noise.Media> without);
		public signal void device_unmounted ();
		public signal void infobar_message (string message, Gtk.MessageType type);
		public signal void initialized (Noise.Device d);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public interface LibraryWindowInterface : GLib.Object {
		public abstract void updateInfoLabel ();
		public abstract async void update_sensitivities ();
		public signal void add_preference_page (Noise.SettingsWindow.NoteBook_Page widget);
		public signal void media_half_played (Noise.Media m);
		public signal void source_list_added (GLib.Object o, int view_number);
		public signal void update_media_info (Noise.Media m);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public interface NetworkDevice : GLib.Object {
		public abstract void finish_initialization ();
		public abstract string getContentType ();
		public abstract string getDisplayName ();
		public abstract Gee.Collection<Noise.Media> get_audiobooks ();
		public abstract void get_device_type ();
		public abstract string get_fancy_description ();
		public abstract Gdk.Pixbuf get_icon ();
		public abstract Gee.Collection<Noise.Media> get_medias ();
		public abstract string get_path ();
		public abstract Gee.Collection<Noise.Playlist> get_playlists ();
		public abstract Gee.Collection<Noise.Media> get_podcasts ();
		public abstract Gee.Collection<Noise.SmartPlaylist> get_smart_playlists ();
		public abstract Gee.Collection<Noise.Media> get_songs ();
		public abstract void setDisplayName (string name);
		public abstract void set_icon (Gdk.Pixbuf icon);
		public abstract bool start_initialization ();
		public abstract bool supports_audiobooks ();
		public abstract bool supports_podcasts ();
		public abstract void unmount ();
		public signal void device_unmounted ();
		public signal void initialized ();
		public signal void progress_notification (string? message, double progress);
		public signal void sync_finished (bool success);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public interface Playback : GLib.Object {
		public abstract void disable_equalizer ();
		public abstract void enable_equalizer ();
		public abstract int64 get_duration ();
		public abstract int64 get_position ();
		public abstract Gee.Collection<string> get_supported_uri ();
		public abstract double get_volume ();
		public abstract void pause ();
		public abstract void play ();
		public abstract void set_equalizer_gain (int index, int val);
		public abstract void set_media (Noise.Media media);
		public abstract void set_position (int64 pos);
		public abstract void set_state (Gst.State s);
		public abstract void set_volume (double val);
		public abstract bool update_position ();
		public signal void current_position_update (int64 position);
		public signal void end_of_stream ();
		public signal void error_occured ();
		public signal void media_not_found ();
	}
	[CCode (cheader_filename = "noise-core.h")]
	public interface Player : GLib.Object {
		public enum Repeat {
			OFF,
			MEDIA,
			ALBUM,
			ARTIST,
			ALL
		}
		public enum Shuffle {
			OFF,
			ALL
		}
		public abstract void add_playback (Noise.Playback p);
	}
	[CCode (cheader_filename = "noise-core.h")]
	public static Noise.LibrariesManager libraries_manager;
	[CCode (cheader_filename = "noise-core.h")]
	public const string[] MEDIA_CONTENT_TYPES;
	[CCode (cheader_filename = "noise-core.h")]
	public const string MUSIC_PLAYLIST;
	[CCode (cheader_filename = "noise-core.h")]
	public const string[] PLAYLISTS_CONTENT_TYPES;
	[CCode (cheader_filename = "noise-core.h")]
	public const string STRING_CANCEL;
	[CCode (cheader_filename = "noise-core.h")]
	public const string STRING_OPEN;
	[CCode (cheader_filename = "noise-core.h")]
	public const string STRING_SAVE;
}
